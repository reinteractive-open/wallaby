# Controller

> NOTE: this is a documentation for 5.2.0 and above, if Wallaby version under 5.2.0 is used, please see this [document for 5.1 and below](controller.5.1.md).

Apart from additional supporting functions, Wallaby controllers are just ordinary Rails controllers that have implemented resourceful actions which can be overridden for customization.

First of all, it's always recommended to create a base controller class `Admin::ApplicationController` as below, so that devs can have better control of developing global changes/functions:

```ruby
# app/controllers/admin/application_controller.rb
class Admin::ApplicationController < Wallaby::ResourcesController
end
```

This base controller can be generated by Wallaby generator as well (since 5.2.0):

```shell
rails g wallaby:install
```

> See [Mapping - Controller](configuration.md#controller) for the configuration if `Admin::ApplicationController` is taken for other purpose.

Starting with:

- [Declaration](#declaration)

Configuration can be set for:

- [.base_class!](#base_class) (since 5.2.0) - flagging as base class.
- [.namespace](#namespace) (since 5.2.0) - specifying the namespace so that model class can be detected.
- [.model_class](#model_class) - specifying the model class.

The following resourcesful actions can be customized:

- [index](#index) - collection listing page.
- [new](#new) - resource form for creation.
- [create](#create) - handling resource creation.
- [show](#show) - single resource display page.
- [edit](#edit) - resource form for editing.
- [update](#update) - handling resource update.
- [destroy](#destroy) - handling resource deletion.

Customize non-resourcesful actions:

- [home](#home) (since 5.1.0) - customizing landing page.

Also it is possible to:

- [collection](#collection) - to customize how collection should be returned.
- [resource](#resource) - to customize how resource should be returned.
- [authenticate_user!](#authenticate_user) - to customize how user should be authenticated.
- [current_user](#current_user) - to customize how current user record should be returned.
- [resource_params](#resource_params) - to customize the white-listed parameters for mass assignment.

More advanced configuration:

- [theme_name](advanced_controller.md#theme_name) (since 5.2.0) - specifying the theme.
- [engine_name](advanced_controller.md#engine_name) (since 5.2.0) - specifying the name of engine helper.
- [application_decorator](advanced_controller.md#application_decorator) (since 5.2.0) - specifying the base resource decorator class.
- [resource_decorator](advanced_controller.md#resource_decorator) (since 5.2.0) - specifying the resource decorator class.
- [application_servicer](advanced_controller.md#application_servicer) (since 5.2.0) - specifying the base model servicer class.
- [model_servicer](advanced_controller.md#model_servicer) (since 5.2.0) - specifying the model servicer class.
- [application_authorizer](advanced_controller.md#application_authorizer) (since 5.2.0) - specifying the base model authorizer class.
- [model_authorizer](advanced_controller.md#model_authorizer) (since 5.2.0) - specifying the model authorizer class.
- [application_paginator](advanced_controller.md#application_paginator) (since 5.2.0) - specifying the base model paginator class.
- [model_paginator](advanced_controller.md#model_paginator) (since 5.2.0) - specifying the model paginator class.

## Declaration

> Read more at [Controller Naming Convention](convention.md#controller)

Let's see how a controller can be created so that Wallaby knows its existence.

Similar to the way in Rails, create a custom controller for model `Product` inheriting from `Admin::ApplicationController` (the base controller mentioned [above](#controller)) as below:

```ruby
# app/controllers/products_controller.rb
class ProductsController < Admin::ApplicationController
end
```

> NOTE: although it inherits from `Admin::ApplicationController`, it is possible to access to all methods in `::ApplicationController`. Because `Admin::ApplicationController` inherits from `ApplicationController` unless this is changed in Wallaby [authentication configuration](configuration.md#authentication).

If `ProductsController` is taken, it is still possible to use another name (e.g. `Admin::ProductsController`). However, the attribute `model_class` must be specified. See [`model_class`](#model_class) for examples.

## .base_class!

> since 5.2.0

All controllers will be preloaded and processed by Wallaby in order to build up the mapping between controllers and models. If the controller is considered not to be processed, it can be flagged by using `base_class!`:

```ruby
# app/controllers/admin/special_controller.rb
class Admin::SpecialController < Admin::ApplicationController
  base_class!
end
```

## .namespace

> since 5.2.0

If all controllers are going to be placed under a namespace, for example, `Admin`, then namespace can be configured:

```ruby
# app/controllers/admin/application_controller.rb
class Admin::ApplicationController < Wallaby::ResourcesController
  self.namespace = 'Admin'
end
```

So that all its subclasses can detect its associated model class correctly and no [.model_class](#model_class) needs to be configured:

```ruby
class Admin::ProductsController < Admin::ApplicationController
end

Admin::ProductsController.model_class
# => Product
```

## .model_class

According to Wallaby's [Controller Naming Convention](convention.md#controller), if a custom controller cannot reflect the association to the correct model, for example, as `Admin::ProductsController` to `Product`, it is required to specify the model class in the controller as below:

```ruby
# app/controllers/admin/products_controller.rb
class Admin::ProductsController < Admin::ApplicationController
  self.model_class = Product
end
```

For version below 5.2.0, it is:

```ruby
# app/controllers/admin/products_controller.rb
class Admin::ProductsController < Admin::ApplicationController
  def self.model_class
    Product
  end
end
```

# Basic Customization

## index

To customize index action, it goes:

```ruby
def index
  # do something before the origin action
  index!(
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def index(options = {}, &block)
  current_authorizer.authorize :index, current_model_class
  respond_with collection, options, &block
end
```

It can be completely replaced like:

```ruby
def index
  @collection = Product.all
end
```

> NOTE: `@collection` MUST be assigned, because it's the only instance variable used in the view.

## new

To customize new action, it goes:

```ruby
def new
  # do something before the origin action
  new!(
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def new(options = {}, &block)
  current_authorizer.authorize :new, resource
  respond_with resource, options, &block
end
```

It can be completely replaced like:

```ruby
def new
  @resource = Product.new new_arrival: true
end
```

> NOTE: `@resource` MUST be assigned, because it's the only instance variable used in the view.

## create

> NOTE: `create` action works differently since 5.2.0. See below and the [Controller for 5.1 and below](controller.5.1.md).

To customize create action, it goes:

```ruby
def create
  # do something before the origin action
  create!(
    params: nil, # params to use for the servicer
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def create(options = {}, &block)
  set_defaults_for :create, options
  current_authorizer.authorize :create, resource
  current_servicer.create resource, options.delete(:params)
  respond_with resource, options, &block
end
```

It can be completely replaced like:

```ruby
def create
  @resource = Product.create(resource_params.merge new_arrival: true)
end
```

> NOTE: `@resource` MUST be assigned, because it's the only instance variable used in the view.

## show

To customize show action, it goes:

```ruby
def show
  # do something before the origin action
  show!(
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def show(options = {}, &block)
  current_authorizer.authorize :show, resource
  respond_with resource, options, &block
end
```

It can be completely replaced like:

```ruby
def show
  @resource = Product.friendly.find params[:id]
end
```

> NOTE: `@resource` MUST be assigned, because it's the only instance variable used in the view.

## edit

To customize edit action, it goes:

```ruby
def edit
  # do something before the origin action
  edit!(
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def edit(options = {}, &block)
  current_authorizer.authorize :edit, resource
  respond_with resource, options, &block
end
```

It can be completely replaced like:

```ruby
def edit
  @resource = Product.friendly.find params[:id]
end
```

> NOTE: `@resource` MUST be assigned, because it's the only instance variable used in the view.

## update

> NOTE: `update` action works differently since 5.2.0. See below and the [Controller for 5.1 and below](controller.5.1.md).

To customize update action, it goes:

```ruby
def update
  # do something before the origin action
  update!(
    params: nil, # params to use for the servicer
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def update(options = {}, &block)
  set_defaults_for :update, options
  current_authorizer.authorize :update, resource
  current_servicer.update resource, options.delete(:params)
  respond_with resource, options, &block
end
```

It can be completely replaced like:

```ruby
def update
  @resource = Product.friendly.find params[:id]
  @resource.update resource_params
end
```

> NOTE: `@resource` MUST be assigned, because it's the only instance variable used in the view.

## destroy

To customize destroy action, it goes:

```ruby
def destroy
  # do something before the origin action
  destroy!(
    params: nil, # params to use for the servicer
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def destroy(options = {}, &block)
  set_defaults_for :destroy, options
  current_authorizer.authorize :destroy, resource
  current_servicer.destroy resource, options.delete(:params)
  respond_with resource, options, &block
end
```

It can be completely replaced like:

```ruby
def destroy
  @resource = Product.friendly.find params[:id]
  @resource.destroy
end
```

> NOTE: `@resource` MUST be assigned, because it's the only instance variable used in the view.

## collection

To customize collection method, it goes:

```ruby
def collection
  collection!(
    params: nil, # params to use for the servicer
    paginate: true # whether to paginate the collection
  ) do |records|
    # do something here after origin query is completed
    # but before `@collection` instance variable is set
    records
  end
end
```

Or it can be completely replaced like:

```ruby
def collection
  @collection ||= Product.new_arrival
end
```

> NOTE: `@collection` MUST be assigned, because it's the only instance variable used in the view.

## resource

To customize resource method, it goes:

```ruby
def resource
  resource!(
    find_params: nil, # params/options for servicer's `find` action
    new_params: nil # params/options for servicer's `new` action
  ) do |record|
    # do something here after origin query is completed
    # but before `@resource` instance variable is set
    record
  end
end
```

Or it can be completely replaced like:

```ruby
def resource
  @resource ||= Product.new_arrival
end
```

> NOTE: `@resource` MUST be assigned, because it's the only instance variable used in the view.

## authenticate_user!

This is the method that Wallaby uses for user authentication. It can be customized in this [Configuration](configuration.md#authenticate_user-and-current_user).

To customize, it goes:

```ruby
def authenticate_user!
  # http basic authentication
  authenticate_or_request_with_http_basic do |username, password|
    username == 'too_simple' && password == 'too_naive'
  end
end
```

## current_user

This is the method that Wallaby uses to return the record for signed-in user. It can be customized in this [Configuration](configuration.md#authenticate_user-and-current_user).

To customize, it goes:

```ruby
def current_user
  # user example
  Class.new do
    def email
      'user@example.com'
    end
  end.new
end
```

## resource_params

Basically, the implementation is as simple as:

```ruby
def resource_params
  @resource_params ||= current_servicer.permit params, action_name
end
```

To customize the parameters to be whitelisted for create and update, it can be overridden:

```ruby
def resource_params
  params.require(:product).permit(:name, :sku)
end
```

## home

> since 5.1.0

`home` action is basically a blank action which renders the `home` template as the landing page of Wallaby (the root_path of where Wallaby engine is mounted) (available since 5.1.0):

```ruby
def home
  # do nothing
end
```

It can be completely replaced like:

```ruby
def home
  @reports = build_reports
end
```
